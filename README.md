Nama  : Prasetyo Adi Wijonarko <br>
Kelas : A <br>
Asdos : DEE <hr>

# TUTORIAL 5
## Hasil Sebelum optimisasi
![1](https://github.com/prasetyoadii/exercise-profiling/assets/125488022/f074e8ce-4263-4647-a2ee-3f9ea7dd7dc6)
![2](https://github.com/prasetyoadii/exercise-profiling/assets/125488022/f708e41f-8318-4976-9b44-0c2e23d069fd)
![3](https://github.com/prasetyoadii/exercise-profiling/assets/125488022/10c0364e-c37f-4775-b58f-24b466aed0a7)
![4](https://github.com/prasetyoadii/exercise-profiling/assets/125488022/618b6e9c-6d43-4459-ab7f-bb6cf81b922a)
![5](https://github.com/prasetyoadii/exercise-profiling/assets/125488022/cbcfe686-d9ff-4ccd-b5e6-567b034b641d)
![6](https://github.com/prasetyoadii/exercise-profiling/assets/125488022/07ff1767-7341-4731-a25f-6fe092633610)
![before1](https://github.com/prasetyoadii/exercise-profiling/assets/125488022/aa1b63da-1243-400b-b891-4d01562be451)
![before 2](https://github.com/prasetyoadii/exercise-profiling/assets/125488022/0281b4f9-0d0a-4698-b51b-7e33bd165812)
![before 3](https://github.com/prasetyoadii/exercise-profiling/assets/125488022/70663bea-aa6b-4204-b84c-5eb4f5f97885)
## Hasil Setelah optimisasi
![after 1](https://github.com/prasetyoadii/exercise-profiling/assets/125488022/9ab7a7ad-cdfa-4682-8b59-984933feb0b1)
![after 2](https://github.com/prasetyoadii/exercise-profiling/assets/125488022/7b87e86a-ec2a-4022-8c41-ce87cd1bc542)
![after 3](https://github.com/prasetyoadii/exercise-profiling/assets/125488022/c057a2e3-f2c7-4fc2-ad62-540a66e1f90a)
![after 4](https://github.com/prasetyoadii/exercise-profiling/assets/125488022/d2491aea-53fa-499d-964c-8013095abb27)
![after 5](https://github.com/prasetyoadii/exercise-profiling/assets/125488022/22842656-49e7-40f7-a52b-03d6954ddeb0)
![after 6](https://github.com/prasetyoadii/exercise-profiling/assets/125488022/c000f995-36f0-48a0-abb1-949cfff821a6)

**Kesimpulan**
Performa dan waktu eksekusi telah meningkat setelah melakukan optimasi menggunakan Intellij Profiler dan performance testing dengan JMeter pada kode-kode awal yang sebelumnya memakan waktu lama. Keberhasilan optimasi ini terbukti dari percepatan waktu eksekusi dalam merespons permintaan.

1. **What is the difference between the approach of performance testing with JMeter and profiling with IntelliJ Profiler in the context of optimizing application performance?** <br>
   Pengujian menggunakan JMeter cenderung bersifat blackbox karena lebih fokus pada evaluasi respons aplikasi terhadap simulasi tindakan pengguna, seperti waktu respons, throughput, dan penggunaan sumber daya. JMeter mengirim permintaan ke endpoint yang ditentukan, menilai keberhasilan eksekusi, dan membantu mengidentifikasi area perbaikan tanpa memperhatikan detail internal aplikasi. Di sisi lain, pendekatan profiling, seperti yang ditawarkan oleh IntelliJ Profiler, menawarkan analisis mendalam terhadap proses internal aplikasi. Profiling memungkinkan identifikasi bagian kode yang memakan waktu, pola penggunaan memori, dan beban kerja CPU, memberikan pemahaman yang lebih mendalam untuk optimalisasi yang efektif. Kombinasi keduanya dapat memberikan wawasan holistik tentang kinerja aplikasi, dengan JMeter fokus pada respons umum dan profiling memberikan wawasan.
2. **How does the profiling process help you in identifying and understanding the weak points in your application?** <br>
   Profil aplikasi membantu memahami dan mengidentifikasi bagaimana kode beroperasi dalam aplikasi dengan memantau perilaku saat aplikasi berjalan, termasuk penggunaan CPU, alokasi memori, panggilan fungsi, dan aktivitas thread. Dengan menganalisis data ini, kita dapat menemukan inefficiencies, titik-titik bottleneck, atau penggunaan sumber daya yang berlebihan. Alat-alat profil menyajikan visualisasi dari eksekusi aplikasi secara real-time, memudahkan identifikasi area kode yang perlu diperbaiki dan memberikan panduan yang lebih terarah untuk optimalisasi.
3. **Do you think IntelliJ Profiler is effective in assisting you to analyze and identify bottlenecks in your application code?** <br>
   Menurut saya, Intellij Profiler merupakan alat yang efektif dalam menganalisis dan mengidentifikasi bottleneck dalam kode program. Dengan bantuan profiler ini, saya dapat dengan mudah melacak dan mengetahui waktu eksekusi terlama pada method tertentu, contohnya pada method getAllStudentWithCourse. Dengan informasi ini, saya dapat mengidentifikasi dengan jelas method mana yang memiliki dampak paling signifikan terhadap kinerja program. Analisis ini sangat membantu dalam mengidentifikasi bottleneck dan memungkinkan saya untuk melakukan optimasi pada kode program guna meningkatkan performa secara keseluruhan.
4. **What are the main challenges you face when conducting performance testing and profiling, and how do you overcome these challenges?** <br>
   Tantangan utama dalam melakukan performance testing dan profiling terletak pada analisis dan pemahaman hasil dari alat seperti JMeter dan IntelliJ Profiler. Data yang dihasilkan terkadang kompleks, khususnya pada Profiler yang mencakup tidak hanya method yang dibuat pengguna, tetapi juga method dari library. Hal ini membuat sulit untuk dengan jelas mengidentifikasi kode mana yang memberikan dampak terbesar terhadap kinerja program. Untuk mengatasi kendala ini, upaya ekstra diperlukan dalam menganalisis hasil dengan teliti dan memahami perbandingannya dengan output sebelumnya. Interpretasi output dan perbandingannya dengan hasil sebelumnya menjadi tantangan utama dalam proses profiling. Dengan jumlah informasi yang banyak dihasilkan oleh alat ini, dibutuhkan pencarian yang cermat untuk mengidentifikasi aspek-aspek kunci yang memengaruhi performa. Perekaman output sebelumnya, seperti melalui tangkapan layar atau merujuk kembali ke profiling sebelumnya, membantu dalam melacak perubahan. Namun, kunci keberhasilan terletak pada kemampuan untuk membandingkan langsung hasil sebelum dan sesudah melakukan optimisasi. Oleh karena itu, kebiasaan dan kehati-hatian dalam menggunakan alat-alat ini menjadi penting untuk mengatasi tantangan tersebut.
5. **What are the main benefits you gain from using IntelliJ Profiler for profiling your application code?** <br>
IntelliJ Profiler mempermudah identifikasi bottlenecks dalam kode tanpa perlu mengandalkan aplikasi pihak ketiga, karena proses profiling terintegrasi langsung dengan lingkungan pengembangan (IDE). Keuntungan utamanya terletak pada kemampuan menemukan kode yang masih dapat dioptimalkan dengan lebih cepat, yang sulit dicapai tanpa menggunakan alat ini. Dibandingkan dengan metode manual tanpa profiling, yang melibatkan membaca kode satu per satu, Profiler memungkinkan saya fokus pada bagian kode yang memakan waktu paling lama untuk dieksekusi, sehingga perbaikan yang ditemukan memiliki dampak yang lebih signifikan terhadap performa secara keseluruhan.
6. **How do you handle situations where the results from profiling with IntelliJ Profiler are not entirely consistent with findings from performance testing using JMeter?** <br>
Langkah awal saat menemukan perbedaan hasil antara JMeter dan IntelliJ Profiler adalah memeriksa kembali metode pengujian dan skenario yang digunakan dalam keduanya. Perbandingan metrik yang diukur perlu dilakukan untuk mengidentifikasi perbedaan fokus atau ruang lingkup, seperti perangkat keras atau perangkat lunak yang berbeda. Untuk mengatasi ketidak konsistenan hasil, saya melakukan lebih banyak performance testing pada JMeter dan menghindari menggunakan hasil pertama kali saat program berjalan, memperhitungkan JIT compiler pada JVM yang belum sepenuhnya optimal. Hingga saat ini, belum terdapat ketidak konsistenan dalam hasil performance testing antara IntelliJ Profiler dan JMeter, menunjukkan bahwa keduanya memberikan pandangan yang konsisten terhadap performa aplikasi dalam konteks pengujian kode yang saya lakukan.
7. **What strategies do you implement in optimizing application code after analyzing results from performance testing and profiling? How do you ensure the changes you make do not affect the application's functionality?** <br>
   Setelah melakukan tes dan profiling, saya mengevaluasi respons program terhadap permintaan melalui JMeter. Jika respons terasa lambat, saya menggunakan profiler untuk mengidentifikasi kode yang menyebabkan penundaan dan mencari solusi untuk mempercepatnya. Untuk memverifikasi keakuratan kode pasca-modifikasi, saya memastikan bahwa outputnya tetap konsisten. Pendekatan yang lebih efektif adalah membuat unit test, seperti dijelaskan dalam tutorial sebelumnya. Dengan menjalankan unit test yang berhasil, dapat diasumsikan bahwa kode yang direfaktor berfungsi dengan baik, memungkinkan fokus perbaikan pada aspek yang memerlukan peningkatan tanpa mengubah seluruh bagian kode.
